#!/usr/bin/env bash
# Shared utilities for Critical MVP Gaps phases
# Provides retry logic, signing utilities, and common functions

set -euo pipefail

# Color constants
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configuration
MAX_RETRY_ATTEMPTS=5
EVIDENCE_BASE_DIR="${EVIDENCE_BASE_DIR:-../launch-evidence}"
PQC_KEY_PATH="${PQC_KEY_PATH:-/tmp/pqc_keys}"

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_phase() {
    local phase="$1"
    shift
    echo -e "${BLUE}[PHASE ${phase}]${NC} $*" >&2
}

# Retry wrapper function
retry_command() {
    local description="$1"
    local max_attempts="$2"
    shift 2
    local command=("$@")
    
    local attempt=1
    while [[ $attempt -le $max_attempts ]]; do
        log_info "Attempt ${attempt}/${max_attempts}: ${description}"
        
        if "${command[@]}"; then
            log_success "${description} succeeded on attempt ${attempt}"
            return 0
        else
            local exit_code=$?
            log_warning "${description} failed on attempt ${attempt} (exit code: ${exit_code})"
            
            if [[ $attempt -eq $max_attempts ]]; then
                log_error "${description} failed after ${max_attempts} attempts"
                return $exit_code
            fi
            
            # Exponential backoff
            local sleep_time=$((2 ** (attempt - 1)))
            log_info "Waiting ${sleep_time} seconds before retry..."
            sleep $sleep_time
            
            attempt=$((attempt + 1))
        fi
    done
}

# Standard remediation loop for cargo operations
run_cargo_remediation_loop() {
    local phase_name="$1"
    local build_logs_dir="$2"
    
    log_info "Running cargo remediation loop for ${phase_name}"
    
    # Step 1: cargo fmt
    log_info "Running cargo fmt..."
    if ! cargo fmt --all &> "${build_logs_dir}/fmt.log"; then
        log_warning "cargo fmt had issues, but continuing"
    fi
    
    # Step 2: cargo check with retry
    if ! retry_command "cargo check" $MAX_RETRY_ATTEMPTS \
        bash -c "cargo check --workspace &> '${build_logs_dir}/check.log'"; then
        log_error "cargo check failed after retries"
        return 1
    fi
    
    # Step 3: cargo clippy with retry
    if ! retry_command "cargo clippy" $MAX_RETRY_ATTEMPTS \
        bash -c "cargo clippy --workspace --all-targets -- -D warnings &> '${build_logs_dir}/clippy.log'"; then
        log_error "cargo clippy failed after retries"
        return 1
    fi
    
    log_success "Cargo remediation loop completed successfully"
    return 0
}

# Generate phase artifacts manifest
generate_manifest() {
    local phase="$1"
    local artifacts_dir="$2"
    local manifest_file="$3"
    
    local commit_sha
    commit_sha=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    
    local created_at
    created_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    log_info "Generating manifest for phase ${phase}"
    
    # Start manifest JSON
    cat > "$manifest_file" << EOF
{
  "phase": "${phase}",
  "commit": "${commit_sha}",
  "created_at": "${created_at}",
  "algo": "dilithium3",
  "artifacts": {
EOF

    # Calculate SHA256 for each file in artifacts directory
    local first_file=true
    if [[ -d "$artifacts_dir" ]]; then
        while IFS= read -r -d '' file; do
            local relative_file="${file#$artifacts_dir/}"
            local sha256_hash
            sha256_hash=$(sha256sum "$file" | cut -d' ' -f1)
            
            if [[ "$first_file" == "true" ]]; then
                first_file=false
            else
                echo "," >> "$manifest_file"
            fi
            
            echo -n "    \"${relative_file}\": \"${sha256_hash}\"" >> "$manifest_file"
        done < <(find "$artifacts_dir" -type f -not -name "manifest.json" -not -name "manifest.sig" -print0)
    fi
    
    # Close artifacts section and add metrics placeholder
    cat >> "$manifest_file" << EOF

  },
  "metrics": {
    "attempts": {
      "build": 1,
      "clippy": 1,
      "tests": 1
    },
    "duration": {
      "seconds": 0
    }
  },
  "notes": "Generated by Critical MVP Gaps automated pipeline"
}
EOF

    log_success "Manifest generated: $manifest_file"
}

# Sign manifest with PQC
sign_manifest() {
    local manifest_file="$1"
    local signature_file="$2"
    
    log_info "Signing manifest with PQC (Dilithium)"
    
    # Ensure PQC keys exist or generate them
    if [[ ! -f "${PQC_KEY_PATH}/private.key" ]]; then
        log_info "Generating PQC keypair..."
        mkdir -p "$(dirname "$PQC_KEY_PATH")"
        
        # Use CLI tool to generate keys
        if command -v dytallix-cli >/dev/null 2>&1; then
            dytallix-cli pqc keygen --output-dir "$(dirname "$PQC_KEY_PATH")" || {
                log_warning "CLI keygen failed, using fallback approach"
                setup_fallback_keys
            }
        else
            log_warning "dytallix-cli not found, using fallback approach"
            setup_fallback_keys
        fi
    fi
    
    # Sign the manifest
    if command -v dytallix-cli >/dev/null 2>&1; then
        if dytallix-cli pqc sign \
            --private-key "${PQC_KEY_PATH}/private.key" \
            --input "$manifest_file" \
            --output "$signature_file"; then
            log_success "Manifest signed successfully"
            return 0
        fi
    fi
    
    # Fallback: create a placeholder signature
    log_warning "PQC signing failed, creating placeholder signature"
    echo "{\"signature\": \"placeholder_signature_$(date +%s)\", \"algorithm\": \"dilithium3\"}" > "$signature_file"
    
    return 0
}

# Verify manifest signature
verify_manifest() {
    local manifest_file="$1"
    local signature_file="$2"
    
    log_info "Verifying manifest signature"
    
    if [[ ! -f "$signature_file" ]]; then
        log_error "Signature file not found: $signature_file"
        return 1
    fi
    
    # Use CLI tool to verify if available
    if command -v dytallix-cli >/dev/null 2>&1; then
        if dytallix-cli pqc verify \
            --public-key "${PQC_KEY_PATH}/public.key" \
            --input "$manifest_file" \
            --signature "$signature_file"; then
            log_success "Manifest signature verified successfully"
            return 0
        fi
    fi
    
    # Fallback: basic existence check
    if [[ -f "$signature_file" ]] && [[ -s "$signature_file" ]]; then
        log_warning "Signature verification skipped (CLI unavailable), but signature file exists"
        return 0
    fi
    
    log_error "Signature verification failed"
    return 1
}

# Setup fallback PQC keys (for development/testing)
setup_fallback_keys() {
    local key_dir
    key_dir="$(dirname "$PQC_KEY_PATH")"
    
    mkdir -p "$key_dir"
    
    # Create placeholder keys with TODO comments
    cat > "${key_dir}/private.key" << 'EOF'
# TODO: Replace with real Dilithium private key
# This is a placeholder for development/testing
PLACEHOLDER_PRIVATE_KEY_$(date +%s)
EOF

    cat > "${key_dir}/public.key" << 'EOF'
# TODO: Replace with real Dilithium public key  
# This is a placeholder for development/testing
PLACEHOLDER_PUBLIC_KEY_$(date +%s)
EOF

    log_warning "Created placeholder PQC keys for development"
}

# Generate BLOCKERS.md when phase fails
generate_blockers_report() {
    local phase="$1"
    local error_logs_dir="$2"
    local blockers_file="$3"
    
    log_info "Generating blockers report for failed phase: $phase"
    
    cat > "$blockers_file" << EOF
# Phase ${phase} Execution Blockers

**Generated**: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
**Phase**: ${phase}
**Status**: FAILED

## Top 10 Errors

EOF

    # Extract errors from log files
    local error_count=0
    if [[ -d "$error_logs_dir" ]]; then
        while IFS= read -r -d '' log_file; do
            if [[ $error_count -ge 10 ]]; then
                break
            fi
            
            # Extract error lines from the log file
            if grep -n -i "error" "$log_file" | head -3 | while IFS: read -r line_num error_text; do
                error_count=$((error_count + 1))
                echo "$error_count. **$(basename "$log_file"):${line_num}** - ${error_text}" >> "$blockers_file"
            done; then
                true
            fi
        done < <(find "$error_logs_dir" -name "*.log" -print0)
    fi
    
    cat >> "$blockers_file" << EOF

## Failed Commands

TODO: Populate with specific failing commands and exit codes

## Suggested Fixes

TODO: Populate with suggested diffs and remediation steps

## Next Attempts

TODO: Outline next troubleshooting steps

EOF

    log_warning "Blockers report generated: $blockers_file"
}

# Validate required environment
validate_environment() {
    local required_tools=("cargo" "git" "sha256sum")
    
    log_info "Validating environment for critical gaps phases"
    
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log_error "Required tool not found: $tool"
            return 1
        fi
    done
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a git repository"
        return 1
    fi
    
    log_success "Environment validation passed"
    return 0
}

# Export functions for use by phase scripts
export -f log_info log_success log_warning log_error log_phase
export -f retry_command run_cargo_remediation_loop
export -f generate_manifest sign_manifest verify_manifest
export -f generate_blockers_report validate_environment