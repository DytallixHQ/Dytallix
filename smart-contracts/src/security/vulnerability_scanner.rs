//! Vulnerability Scanner for Smart Contracts
//!
//! This module implements detection of common smart contract vulnerabilities
//! including reentrancy, integer overflow, access control issues, and more.

use super::{SecurityFinding, Severity, VulnerabilityCategory};
use crate::runtime::{ContractCall, ContractDeployment, ExecutionResult, StateChange};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Pattern-based vulnerability scanner
pub struct VulnerabilityScanner {
    scan_count: u64,
    total_findings: u64,
    patterns: VulnerabilityPatterns,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            scan_count: 0,
            total_findings: 0,
            patterns: VulnerabilityPatterns::default(),
        }
    }

    /// Scan a contract deployment for vulnerabilities
    pub fn scan_deployment(&mut self, deployment: &ContractDeployment) -> Vec<SecurityFinding> {
        self.scan_count += 1;
        let mut findings = Vec::new();

        // 1. Scan WASM bytecode for suspicious patterns
        findings.extend(self.scan_wasm_bytecode(&deployment.code, &deployment.address));

        // 2. Check deployment parameters
        findings.extend(self.check_deployment_security(deployment));

        // 3. Analyze initial state for vulnerabilities
        findings.extend(self.analyze_initial_state(deployment));

        self.total_findings += findings.len() as u64;
        findings
    }

    /// Check for reentrancy patterns in execution traces
    pub fn check_reentrancy_execution(
        &self,
        call: &ContractCall,
        result: &ExecutionResult,
    ) -> Vec<SecurityFinding> {
        let mut findings = Vec::new();

        // Check for suspicious state change patterns that could indicate reentrancy
        if self.has_reentrancy_pattern(&result.state_changes) {
            findings.push(SecurityFinding {
                id: format!("REENTRANCY-{}", self.generate_finding_id()),
                title: "Potential Reentrancy Attack Detected".to_string(),
                description: "Execution pattern suggests possible reentrancy vulnerability during contract call".to_string(),
                severity: Severity::High,
                category: VulnerabilityCategory::Reentrancy,
                location: Some(format!("Contract: {}, Method: {}", call.contract_address, call.method)),
                evidence: vec![
                    format!("Suspicious state changes: {} modifications", result.state_changes.len()),
                    format!("Gas used: {} / {}", result.gas_used, call.gas_limit),
                ],
                recommendations: vec![
                    "Implement checks-effects-interactions pattern".to_string(),
                    "Use reentrancy guards on external calls".to_string(),
                    "Minimize state changes after external calls".to_string(),
                ],
                gas_impact: Some(result.gas_used),
            });
        }

        findings
    }

    /// Scan WASM bytecode for vulnerability patterns
    fn scan_wasm_bytecode(&self, bytecode: &[u8], address: &str) -> Vec<SecurityFinding> {
        let mut findings = Vec::new();

        // Check WASM magic number and version
        if bytecode.len() < 8 {
            findings.push(SecurityFinding {
                id: format!("WASM-INVALID-{}", self.generate_finding_id()),
                title: "Invalid WASM Contract".to_string(),
                description: "Contract bytecode is too small to be valid WASM".to_string(),
                severity: Severity::Critical,
                category: VulnerabilityCategory::LogicFlaws,
                location: Some(address.to_string()),
                evidence: vec![format!("Bytecode size: {} bytes", bytecode.len())],
                recommendations: vec!["Ensure contract is properly compiled WASM".to_string()],
                gas_impact: None,
            });
            return findings;
        }

        // Check WASM magic number
        if &bytecode[0..4] != b"\x00asm" {
            findings.push(SecurityFinding {
                id: format!("WASM-MAGIC-{}", self.generate_finding_id()),
                title: "Invalid WASM Magic Number".to_string(),
                description: "Contract does not have valid WASM magic number".to_string(),
                severity: Severity::Critical,
                category: VulnerabilityCategory::LogicFlaws,
                location: Some(address.to_string()),
                evidence: vec![format!("Magic bytes: {:?}", &bytecode[0..4])],
                recommendations: vec!["Use properly compiled WASM binary".to_string()],
                gas_impact: None,
            });
        }

        // Check for suspicious patterns in bytecode
        findings.extend(self.detect_bytecode_patterns(bytecode, address));

        findings
    }

    /// Detect suspicious patterns in WASM bytecode
    fn detect_bytecode_patterns(&self, bytecode: &[u8], address: &str) -> Vec<SecurityFinding> {
        let mut findings = Vec::new();

        // Look for patterns that might indicate vulnerabilities

        // 1. Excessive memory operations (potential DoS)
        let memory_ops = self.count_memory_operations(bytecode);
        if memory_ops > self.patterns.max_memory_operations {
            findings.push(SecurityFinding {
                id: format!("MEMORY-DOS-{}", self.generate_finding_id()),
                title: "Excessive Memory Operations".to_string(),
                description:
                    "Contract contains unusual number of memory operations that could lead to DoS"
                        .to_string(),
                severity: Severity::Medium,
                category: VulnerabilityCategory::DoS,
                location: Some(address.to_string()),
                evidence: vec![format!("Memory operations found: {}", memory_ops)],
                recommendations: vec![
                    "Review memory usage patterns".to_string(),
                    "Implement gas-efficient memory operations".to_string(),
                ],
                gas_impact: Some(memory_ops * 100), // Estimated gas impact
            });
        }

        // 2. Unrestricted loops (gas griefing)
        if self.has_unrestricted_loops(bytecode) {
            findings.push(SecurityFinding {
                id: format!("LOOP-GRIEF-{}", self.generate_finding_id()),
                title: "Potential Unbounded Loop".to_string(),
                description: "Contract may contain loops without proper gas controls".to_string(),
                severity: Severity::High,
                category: VulnerabilityCategory::GasGriefing,
                location: Some(address.to_string()),
                evidence: vec!["Unbounded loop patterns detected".to_string()],
                recommendations: vec![
                    "Add loop iteration limits".to_string(),
                    "Implement proper gas checks in loops".to_string(),
                ],
                gas_impact: None,
            });
        }

        // 3. Unchecked arithmetic operations
        let arithmetic_ops = self.count_arithmetic_operations(bytecode);
        if arithmetic_ops > self.patterns.max_arithmetic_operations {
            findings.push(SecurityFinding {
                id: format!("ARITH-OVERFLOW-{}", self.generate_finding_id()),
                title: "High Arithmetic Operation Usage".to_string(),
                description: "Contract performs many arithmetic operations without overflow checks"
                    .to_string(),
                severity: Severity::Medium,
                category: VulnerabilityCategory::IntegerOverflow,
                location: Some(address.to_string()),
                evidence: vec![format!("Arithmetic operations: {}", arithmetic_ops)],
                recommendations: vec![
                    "Use safe arithmetic libraries".to_string(),
                    "Add overflow/underflow checks".to_string(),
                ],
                gas_impact: Some(arithmetic_ops * 10),
            });
        }

        findings
    }

    /// Check deployment security parameters
    fn check_deployment_security(&self, deployment: &ContractDeployment) -> Vec<SecurityFinding> {
        let mut findings = Vec::new();

        // 1. Gas limit analysis
        if deployment.gas_limit > self.patterns.max_gas_limit {
            findings.push(SecurityFinding {
                id: format!("GAS-LIMIT-{}", self.generate_finding_id()),
                title: "Excessive Gas Limit".to_string(),
                description: "Deployment requests unusually high gas limit".to_string(),
                severity: Severity::Medium,
                category: VulnerabilityCategory::GasGriefing,
                location: Some(deployment.address.clone()),
                evidence: vec![format!("Gas limit: {}", deployment.gas_limit)],
                recommendations: vec![
                    "Review gas requirements".to_string(),
                    "Optimize contract for lower gas usage".to_string(),
                ],
                gas_impact: Some(deployment.gas_limit),
            });
        }

        // 2. AI audit score check
        if let Some(score) = deployment.ai_audit_score {
            if score < self.patterns.min_ai_audit_score {
                findings.push(SecurityFinding {
                    id: format!("AI-AUDIT-{}", self.generate_finding_id()),
                    title: "Low AI Audit Score".to_string(),
                    description: "Contract received low score from AI security audit".to_string(),
                    severity: if score < 0.3 {
                        Severity::Critical
                    } else {
                        Severity::High
                    },
                    category: VulnerabilityCategory::LogicFlaws,
                    location: Some(deployment.address.clone()),
                    evidence: vec![format!("AI audit score: {:.2}", score)],
                    recommendations: vec![
                        "Review AI audit findings".to_string(),
                        "Address identified security concerns".to_string(),
                    ],
                    gas_impact: None,
                });
            }
        }

        // 3. Initial state size check
        if deployment.initial_state.len() > self.patterns.max_initial_state_size {
            findings.push(SecurityFinding {
                id: format!("STATE-SIZE-{}", self.generate_finding_id()),
                title: "Large Initial State".to_string(),
                description: "Contract has unusually large initial state".to_string(),
                severity: Severity::Low,
                category: VulnerabilityCategory::GasOptimization,
                location: Some(deployment.address.clone()),
                evidence: vec![format!(
                    "Initial state size: {} bytes",
                    deployment.initial_state.len()
                )],
                recommendations: vec![
                    "Minimize initial state size".to_string(),
                    "Use lazy initialization where possible".to_string(),
                ],
                gas_impact: Some(deployment.initial_state.len() as u64 * 5),
            });
        }

        findings
    }

    /// Analyze initial state for security issues
    fn analyze_initial_state(&self, deployment: &ContractDeployment) -> Vec<SecurityFinding> {
        let mut findings = Vec::new();

        // Check for hardcoded sensitive data patterns
        if self.has_hardcoded_secrets(&deployment.initial_state) {
            findings.push(SecurityFinding {
                id: format!("SECRETS-{}", self.generate_finding_id()),
                title: "Potential Hardcoded Secrets".to_string(),
                description: "Initial state may contain hardcoded sensitive information"
                    .to_string(),
                severity: Severity::High,
                category: VulnerabilityCategory::AccessControl,
                location: Some(deployment.address.clone()),
                evidence: vec!["Suspicious patterns in initial state".to_string()],
                recommendations: vec![
                    "Remove hardcoded secrets from initial state".to_string(),
                    "Use environment variables or secure storage".to_string(),
                ],
                gas_impact: None,
            });
        }

        findings
    }

    /// Check for reentrancy patterns in state changes
    fn has_reentrancy_pattern(&self, state_changes: &[StateChange]) -> bool {
        // Simple heuristic: look for multiple modifications to the same key
        // or rapid succession of state changes that might indicate reentrancy

        let mut key_counts = HashMap::new();
        for change in state_changes {
            *key_counts.entry(&change.key).or_insert(0) += 1;
        }

        // If any key is modified more than twice, it might be reentrancy
        key_counts.values().any(|&count| count > 2) || 
        // Or if there are many state changes in general
        state_changes.len() > 10
    }

    /// Count memory-related operations in WASM bytecode
    fn count_memory_operations(&self, bytecode: &[u8]) -> u64 {
        let mut count = 0;

        // Simple pattern matching for WASM memory opcodes
        // This is a simplified implementation - real WASM parsing would be more complex
        for window in bytecode.windows(2) {
            match window {
                [0x28, _] | [0x29, _] | [0x2a, _] | [0x2b, _] | // load operations
                [0x36, _] | [0x37, _] | [0x38, _] | [0x39, _] | // store operations
                [0x3f, _] | [0x40, _] => count += 1, // memory.size, memory.grow
                _ => {}
            }
        }

        count
    }

    /// Check for patterns that might indicate unbounded loops
    fn has_unrestricted_loops(&self, bytecode: &[u8]) -> bool {
        // Look for loop/block patterns without proper termination
        let mut loop_count = 0;
        let mut conditional_count = 0;

        for &byte in bytecode {
            match byte {
                0x02 | 0x03 => loop_count += 1,        // block, loop
                0x04 | 0x05 => conditional_count += 1, // if, else
                _ => {}
            }
        }

        // Heuristic: many loops with few conditionals might indicate unbounded loops
        loop_count > 5 && (conditional_count as f64 / loop_count as f64) < 0.5
    }

    /// Count arithmetic operations that might overflow
    fn count_arithmetic_operations(&self, bytecode: &[u8]) -> u64 {
        let mut count = 0;

        for &byte in bytecode {
            match byte {
                // Integer arithmetic operations
                0x6a..=0x78 | 0x7c..=0x89 => count += 1,
                // Float arithmetic operations
                0x92..=0xa6 => count += 1,
                _ => {}
            }
        }

        count
    }

    /// Check for patterns that might indicate hardcoded secrets
    fn has_hardcoded_secrets(&self, state: &[u8]) -> bool {
        // Look for patterns that might be keys, tokens, or other secrets
        if state.len() < 16 {
            return false;
        }

        // Check for high entropy regions (might be keys)
        let entropy = self.calculate_entropy(state);
        if entropy > 0.9 {
            return true;
        }

        // Check for common secret patterns (base64, hex strings, etc.)
        let state_str = String::from_utf8_lossy(state);

        // Look for base64-like patterns
        if state_str
            .chars()
            .all(|c| c.is_alphanumeric() || c == '+' || c == '/' || c == '=')
            && state_str.len() % 4 == 0
            && state_str.len() >= 32
        {
            return true;
        }

        // Look for hex patterns
        if state_str.len() >= 32 && state_str.chars().all(|c| c.is_ascii_hexdigit()) {
            return true;
        }

        false
    }

    /// Calculate entropy of data (0.0 = no entropy, 1.0 = maximum entropy)
    fn calculate_entropy(&self, data: &[u8]) -> f64 {
        let mut frequencies = [0u64; 256];
        for &byte in data {
            frequencies[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0;

        for &freq in &frequencies {
            if freq > 0 {
                let p = freq as f64 / len;
                entropy -= p * p.log2();
            }
        }

        entropy / 8.0 // Normalize to [0, 1]
    }

    /// Generate unique finding ID
    fn generate_finding_id(&self) -> String {
        format!(
            "{:08x}",
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_nanos() as u32
        )
    }

    pub fn get_scan_count(&self) -> u64 {
        self.scan_count
    }

    pub fn get_total_findings(&self) -> u64 {
        self.total_findings
    }
}

/// Configuration for vulnerability detection patterns
#[derive(Debug, Clone)]
struct VulnerabilityPatterns {
    max_memory_operations: u64,
    max_arithmetic_operations: u64,
    max_gas_limit: u64,
    min_ai_audit_score: f64,
    max_initial_state_size: usize,
}

impl Default for VulnerabilityPatterns {
    fn default() -> Self {
        Self {
            max_memory_operations: 1000,
            max_arithmetic_operations: 500,
            max_gas_limit: 10_000_000,
            min_ai_audit_score: 0.5,
            max_initial_state_size: 10_000, // 10KB
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::runtime::ContractDeployment;

    #[test]
    fn test_vulnerability_scanner_creation() {
        let scanner = VulnerabilityScanner::new();
        assert_eq!(scanner.get_scan_count(), 0);
        assert_eq!(scanner.get_total_findings(), 0);
    }

    #[test]
    fn test_invalid_wasm_detection() {
        let mut scanner = VulnerabilityScanner::new();

        // Test with invalid WASM (too small)
        let invalid_deployment = ContractDeployment {
            address: "test".to_string(),
            code: vec![1, 2, 3], // Too small to be valid WASM
            initial_state: vec![],
            gas_limit: 100_000,
            deployer: "deployer".to_string(),
            timestamp: 0,
            ai_audit_score: Some(0.8),
        };

        let findings = scanner.scan_deployment(&invalid_deployment);
        assert!(!findings.is_empty());
        assert!(findings.iter().any(|f| f.severity == Severity::Critical));
    }

    #[test]
    fn test_gas_limit_check() {
        let mut scanner = VulnerabilityScanner::new();

        let high_gas_deployment = ContractDeployment {
            address: "test".to_string(),
            code: b"\x00asm\x01\x00\x00\x00".to_vec(), // Valid WASM header
            initial_state: vec![],
            gas_limit: 20_000_000, // Very high gas limit
            deployer: "deployer".to_string(),
            timestamp: 0,
            ai_audit_score: Some(0.8),
        };

        let findings = scanner.scan_deployment(&high_gas_deployment);
        assert!(findings
            .iter()
            .any(|f| f.category == VulnerabilityCategory::GasGriefing));
    }

    #[test]
    fn test_ai_audit_score_check() {
        let mut scanner = VulnerabilityScanner::new();

        let low_score_deployment = ContractDeployment {
            address: "test".to_string(),
            code: b"\x00asm\x01\x00\x00\x00".to_vec(),
            initial_state: vec![],
            gas_limit: 100_000,
            deployer: "deployer".to_string(),
            timestamp: 0,
            ai_audit_score: Some(0.2), // Low AI audit score
        };

        let findings = scanner.scan_deployment(&low_score_deployment);
        assert!(findings.iter().any(|f| f.title.contains("AI Audit Score")));
    }

    #[test]
    fn test_entropy_calculation() {
        let scanner = VulnerabilityScanner::new();

        // Low entropy data (all zeros)
        let low_entropy = vec![0u8; 100];
        assert!(scanner.calculate_entropy(&low_entropy) < 0.1);

        // High entropy data (random-like)
        let high_entropy: Vec<u8> = (0..100).map(|i| (i * 17) as u8).collect();
        assert!(scanner.calculate_entropy(&high_entropy) > 0.5);
    }

    #[test]
    fn test_reentrancy_pattern_detection() {
        let scanner = VulnerabilityScanner::new();

        // Create state changes that might indicate reentrancy
        let suspicious_changes = vec![
            StateChange {
                contract_address: "test".to_string(),
                key: b"balance".to_vec(),
                old_value: Some(b"100".to_vec()),
                new_value: b"90".to_vec(),
            },
            StateChange {
                contract_address: "test".to_string(),
                key: b"balance".to_vec(),
                old_value: Some(b"90".to_vec()),
                new_value: b"80".to_vec(),
            },
            StateChange {
                contract_address: "test".to_string(),
                key: b"balance".to_vec(),
                old_value: Some(b"80".to_vec()),
                new_value: b"70".to_vec(),
            },
        ];

        assert!(scanner.has_reentrancy_pattern(&suspicious_changes));

        // Normal state changes should not trigger
        let normal_changes = vec![StateChange {
            contract_address: "test".to_string(),
            key: b"balance".to_vec(),
            old_value: Some(b"100".to_vec()),
            new_value: b"90".to_vec(),
        }];

        assert!(!scanner.has_reentrancy_pattern(&normal_changes));
    }
}
