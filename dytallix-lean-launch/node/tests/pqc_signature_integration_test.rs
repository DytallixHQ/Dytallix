/// Integration test for PQC signature validation between CLI and node
/// This test verifies that a Dilithium5 signature generated by the CLI
/// can be successfully verified by the node using the exact same workflow
use dytallix_lean_node::types::tx::{Msg, SignedTx, Tx};
use dytallix_lean_node::crypto::{canonical_json, sha3_256};
use pqcrypto_dilithium::dilithium5;
use pqcrypto_traits::sign::{PublicKey, SignedMessage};
use base64::{engine::general_purpose::STANDARD as B64, Engine};

#[test]
fn test_cli_signature_verification() {
    // 1. Generate a Dilithium5 keypair (simulating CLI keygen)
    let (public_key, secret_key) = dilithium5::keypair();
    
    // 2. Create a test transaction (identical to what CLI would create)
    let tx = Tx {
        chain_id: "dyt-local-1".to_string(),
        nonce: 0,
        msgs: vec![Msg::Send {
            from: "dytallix1test000000000000000000000000000".to_string(),
            to: "dytallix1recipient00000000000000000000".to_string(),
            denom: "DGT".to_string(),
            amount: 1000000,
        }],
        fee: 1000,
        memo: "".to_string(),
    };

    // 3. Create canonical JSON (exactly as CLI does)
    let canonical_bytes = canonical_json(&tx).expect("canonical_json should succeed");
    
    // 4. Hash the canonical JSON with SHA3-256 (exactly as CLI does)
    let hash = sha3_256(&canonical_bytes);
    
    println!("Transaction canonical JSON: {}", String::from_utf8_lossy(&canonical_bytes));
    println!("Transaction hash: {}", hex::encode(&hash));
    
    // 5. Sign the hash with Dilithium5 (exactly as CLI does via pqc-sign)
    let signed_message = dilithium5::sign(&hash, &secret_key);
    let signature_bytes = signed_message.as_bytes();
    
    println!("Signature length: {} bytes", signature_bytes.len());
    println!("Public key length: {} bytes", public_key.as_bytes().len());
    
    // 6. Create a SignedTx (what the node receives from RPC)
    // Note: SignedTx expects base64-encoded strings for signature and public_key
    let signed_tx = SignedTx {
        tx: tx.clone(),
        signature: B64.encode(signature_bytes),
        public_key: B64.encode(public_key.as_bytes()),
        algorithm: "dilithium5".to_string(),
        version: 1,
    };
    
    println!("SignedTx created:");
    println!("  signature (base64): {} chars", signed_tx.signature.len());
    println!("  public_key (base64): {} chars", signed_tx.public_key.len());
    
    // 7. Verify the signature using the node's verification logic
    let verification_result = signed_tx.verify();
    
    match verification_result {
        Ok(()) => {
            println!("✅ Signature verification succeeded!");
        }
        Err(e) => {
            panic!("❌ Signature verification failed: {:?}", e);
        }
    }
    
    // 8. Double-check by manually opening the signed message
    let opened_result = dilithium5::open(&signed_message, &public_key);
    match opened_result {
        Ok(recovered_hash) => {
            assert_eq!(
                recovered_hash,
                hash,
                "Recovered hash should match original"
            );
            println!("✅ Manual signature verification with open() succeeded!");
        }
        Err(e) => {
            panic!("❌ Manual signature verification failed: {:?}", e);
        }
    }
}

#[test]
fn test_cli_exact_signature_format() {
    // This test verifies the exact format of signatures as generated by the CLI
    
    let (public_key, secret_key) = dilithium5::keypair();
    
    // Create a minimal transaction
    let tx = Tx {
        chain_id: "test".to_string(),
        nonce: 0,
        msgs: vec![],
        fee: 0,
        memo: "".to_string(),
    };
    
    let canonical_bytes = canonical_json(&tx).expect("canonical_json should succeed");
    let hash = sha3_256(&canonical_bytes);
    
    // Sign the hash
    let signed_message = dilithium5::sign(&hash, &secret_key);
    
    // The CLI outputs the full SignedMessage, which is signature + message
    // For Dilithium5, this should be 4659 bytes (4627 sig + 32 msg for a 32-byte hash)
    let sig_bytes = signed_message.as_bytes();
    println!("SignedMessage length: {} bytes", sig_bytes.len());
    
    // Expected: 4627 (signature) + 32 (message length) = 4659 bytes
    assert_eq!(
        sig_bytes.len(),
        4659,
        "SignedMessage should be 4659 bytes for a 32-byte hash"
    );
    
    // Verify we can open it
    let opened = dilithium5::open(&signed_message, &public_key).expect("should open");
    assert_eq!(opened, hash, "Recovered message should match original hash");
    
    // Now test that the node can verify this using SignedTx with base64 encoding
    let signed_tx = SignedTx {
        tx,
        signature: B64.encode(sig_bytes),
        public_key: B64.encode(public_key.as_bytes()),
        algorithm: "dilithium5".to_string(),
        version: 1,
    };
    
    signed_tx.verify().expect("SignedTx verification should succeed");
    println!("✅ CLI signature format is compatible with node verification");
}

#[test]
fn test_real_world_transaction_flow() {
    // Simulate the complete E2E flow:
    // 1. User has a keypair
    // 2. User creates and signs a transaction
    // 3. User submits to node via RPC
    // 4. Node verifies the signature
    
    println!("=== Simulating Real-World E2E Transaction Flow ===\n");
    
    // Step 1: User keypair (from keystore)
    let (public_key, secret_key) = dilithium5::keypair();
    let address = format!("dytallix1{}", hex::encode(&public_key.as_bytes()[..20]));
    println!("1. User address: {}", address);
    println!("   Public key length: {} bytes", public_key.as_bytes().len());
    
    // Step 2: User creates a transaction
    let tx = Tx {
        chain_id: "dyt-local-1".to_string(),
        nonce: 0,
        msgs: vec![Msg::Send {
            from: address.clone(),
            to: "dytallix1test000000000000000000000000000".to_string(),
            denom: "DGT".to_string(),
            amount: 1000000,
        }],
        fee: 1000,
        memo: "E2E test".to_string(),
    };
    println!("2. Transaction created");
    
    // Step 3: CLI signs the transaction
    let canonical_bytes = canonical_json(&tx).expect("canonical_json should succeed");
    let hash = sha3_256(&canonical_bytes);
    let signed_message = dilithium5::sign(&hash, &secret_key);
    println!("3. Transaction signed");
    println!("   Canonical JSON: {}", String::from_utf8_lossy(&canonical_bytes));
    println!("   Hash: {}", hex::encode(&hash));
    println!("   Signature length: {} bytes", signed_message.as_bytes().len());
    
    // Step 4: CLI submits SignedTx to node via RPC (with base64 encoding)
    let signed_tx = SignedTx {
        tx: tx.clone(),
        signature: B64.encode(signed_message.as_bytes()),
        public_key: B64.encode(public_key.as_bytes()),
        algorithm: "dilithium5".to_string(),
        version: 1,
    };
    println!("4. SignedTx created for RPC submission");
    println!("   Signature (base64): {} chars", signed_tx.signature.len());
    println!("   Public key (base64): {} chars", signed_tx.public_key.len());
    
    // Step 5: Node validates the signature
    println!("5. Node validating signature...");
    match signed_tx.verify() {
        Ok(()) => {
            println!("   ✅ Signature verification PASSED!");
            println!("\n=== E2E Flow Complete: Transaction would be accepted ===");
        }
        Err(e) => {
            panic!("   ❌ Signature verification FAILED: {:?}\n\n=== E2E Flow Failed ===", e);
        }
    }
}
