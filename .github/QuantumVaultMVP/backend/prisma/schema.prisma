generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum AssetType {
  TLS_CERT
  DATABASE
  API_ENDPOINT
  FILE_SHARE
  KEY
  APPLICATION
  PROTOCOL
  OTHER
}

enum Environment {
  PROD
  STAGE
  DEV
  OTHER
}

enum PqcCompliance {
  COMPLIANT
  NON_COMPLIANT
  UNKNOWN
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum BusinessCriticality {
  LOW
  MEDIUM
  HIGH
}

enum DataSensitivity {
  PUBLIC
  INTERNAL
  CONFIDENTIAL
  RESTRICTED
}

enum Exposure {
  INTERNET_FACING
  INTERNAL
  PARTNER
}

enum AssetStatus {
  AT_RISK
  IN_REMEDIATION
  WRAPPED_PQC
  ATTESTED
}

enum KeyType {
  PRIVATE_KEY
  API_SECRET
  DB_CREDENTIAL
  CONFIG_BLOB
  OTHER
}

enum ScanType {
  DISCOVERY
  RESCAN
  POLICY_VALIDATION
}

enum ScanStatus {
  RUNNING
  SUCCESS
  FAILED
  PARTIAL
}

enum ScanResult {
  NEW
  UPDATED
  UNCHANGED
}

enum ScopeType {
  ALL_ASSETS
  BY_TYPE
  BY_ENVIRONMENT
  BY_TAG
  BY_RISK_LEVEL
  CUSTOM_QUERY
}

enum TransitionStrategy {
  HYBRID
  PQC_ONLY
}

enum EnforcementMode {
  MONITOR_ONLY
  ENFORCE
}

enum AnchorType {
  ROOT_OF_TRUST
  KEY_HIERARCHY
  POLICY_BUNDLE
}

enum AttestationJobStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum AttestationStatus {
  PENDING
  SUCCESS
  FAILED
}

enum UserRole {
  ADMIN
  VIEWER
  SECURITY_ENGINEER
}

// Models

model Asset {
  id                      String              @id @default(uuid())
  name                    String              @unique
  type                    AssetType
  location                String
  environment             Environment
  cryptoAlgorithmsInUse   Json                @map("crypto_algorithms_in_use") // List of { layer, algorithm, key_length, mode }
  pqcCompliance           PqcCompliance       @default(UNKNOWN) @map("pqc_compliance")
  quantumRiskScore        Int                 @default(0) @map("quantum_risk_score")
  riskLevel               RiskLevel           @default(LOW) @map("risk_level")
  businessCriticality     BusinessCriticality @default(LOW) @map("business_criticality")
  dataSensitivity         DataSensitivity     @default(INTERNAL) @map("data_sensitivity")
  exposure                Exposure            @default(INTERNAL)
  lastScanTimestamp       DateTime            @default(now()) @map("last_scan_timestamp") @db.Timestamptz
  status                  AssetStatus         @default(AT_RISK)
  wrapperEnabled          Boolean             @default(false) @map("wrapper_enabled")
  wrapperAlgorithm        String?             @map("wrapper_algorithm")
  wrapperAnchorId         String?             @map("wrapper_anchor_id")
  wrapperLastUpdatedAt    DateTime?           @map("wrapper_last_updated_at") @db.Timestamptz
  
  createdAt               DateTime            @default(now()) @map("created_at") @db.Timestamptz
  updatedAt               DateTime            @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  keyMaterial             AssetKeyMaterial[]
  scanAssets              ScanAsset[]
  policyAssets            PolicyAsset[]
  blockchainAttestations  BlockchainAttestation[]
  wrapperAnchor           EncryptionAnchor?   @relation(fields: [wrapperAnchorId], references: [id])
}

model AssetKeyMaterial {
  id                    String    @id @default(uuid())
  assetId               String    @map("asset_id")
  keyType               KeyType   @map("key_type")
  storageReference      String    @map("storage_reference") // Pointer to secure vault
  wrappedPqcKeyReference String?  @map("wrapped_pqc_key_reference")
  lastWrappedAt         DateTime? @map("last_wrapped_at") @db.Timestamptz
  isPqcWrapped          Boolean   @default(false) @map("is_pqc_wrapped")
  algorithmDetails      Json      @map("algorithm_details")

  asset                 Asset     @relation(fields: [assetId], references: [id])
}

model Scan {
  id                      String      @id @default(uuid())
  triggeredBy             String?     @map("triggered_by") // User ID or system
  scanType                ScanType    @map("scan_type")
  startedAt               DateTime    @default(now()) @map("started_at") @db.Timestamptz
  completedAt             DateTime?   @map("completed_at") @db.Timestamptz
  numberOfAssetsScanned   Int         @default(0) @map("number_of_assets_scanned")
  numberOfNonPqcFound     Int         @default(0) @map("number_of_non_pqc_assets_found")
  status                  ScanStatus  @default(RUNNING)
  errorMessage            String?     @map("error_message")

  scanAssets              ScanAsset[]
}

model ScanAsset {
  id          String      @id @default(uuid())
  scanId      String      @map("scan_id")
  assetId     String      @map("asset_id")
  scanResult  ScanResult  @map("scan_result")
  details     Json?

  scan        Scan        @relation(fields: [scanId], references: [id])
  asset       Asset       @relation(fields: [assetId], references: [id])
}

model EncryptionPolicy {
  id                  String             @id @default(uuid())
  name                String
  description         String?
  scopeType           ScopeType          @map("scope_type")
  scopeDefinition     Json               @map("scope_definition")
  requiredPqcAlgorithms Json             @map("required_pqc_algorithms") // { kem: [], symmetric: [] }
  transitionStrategy  TransitionStrategy @map("transition_strategy")
  enforcementMode     EnforcementMode    @map("enforcement_mode")
  
  isActive            Boolean            @default(true) @map("is_active")
  createdAt           DateTime           @default(now()) @map("created_at") @db.Timestamptz
  updatedAt           DateTime           @updatedAt @map("updated_at") @db.Timestamptz
  createdBy           String?            @map("created_by")

  policyAssets        PolicyAsset[]
}

model PolicyAsset {
  id              String           @id @default(uuid())
  policyId        String           @map("policy_id")
  assetId         String           @map("asset_id")
  isCompliant     Boolean          @default(false) @map("is_compliant")
  lastEvaluatedAt DateTime         @default(now()) @map("last_evaluated_at") @db.Timestamptz

  policy          EncryptionPolicy @relation(fields: [policyId], references: [id])
  asset           Asset            @relation(fields: [assetId], references: [id])
}

model EncryptionAnchor {
  id                   String      @id @default(uuid())
  name                 String
  description          String?
  anchorType           AnchorType  @map("anchor_type")
  associatedPolicyIds  Json        @map("associated_policy_ids") // List of UUIDs
  rootPublicKeyReference String    @map("root_public_key_reference")
  rootKeyAlgorithm     String      @map("root_key_algorithm")
  isActive             Boolean     @default(false) @map("is_active")
  
  createdAt            DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime    @updatedAt @map("updated_at") @db.Timestamptz
  createdBy            String?     @map("created_by")

  attestationJobs      BlockchainAttestationJob[]
  attestations         BlockchainAttestation[]
  wrappedAssets        Asset[]
}

model BlockchainAttestationJob {
  id                String                 @id @default(uuid())
  createdBy         String?                @map("created_by")
  anchorId          String                 @map("anchor_id")
  filters           Json?
  totalAssets       Int                    @default(0) @map("total_assets")
  succeededCount    Int                    @default(0) @map("succeeded_count")
  failedCount       Int                    @default(0) @map("failed_count")
  status            AttestationJobStatus   @default(PENDING)
  createdAt         DateTime               @default(now()) @map("created_at") @db.Timestamptz
  completedAt       DateTime?              @map("completed_at") @db.Timestamptz
  blockchainNetwork String                 @map("blockchain_network")

  anchor            EncryptionAnchor       @relation(fields: [anchorId], references: [id])
  attestations      BlockchainAttestation[]
}

model BlockchainAttestation {
  id                String                   @id @default(uuid())
  jobId             String                   @map("job_id")
  assetId           String                   @map("asset_id")
  anchorId          String                   @map("anchor_id")
  attestationStatus AttestationStatus        @default(PENDING) @map("attestation_status")
  blockchainTxId    String?                  @map("blockchain_tx_id")
  attestedAt        DateTime?                @map("attested_at") @db.Timestamptz
  errorMessage      String?                  @map("error_message")
  payloadHash       String                   @map("payload_hash")

  job               BlockchainAttestationJob @relation(fields: [jobId], references: [id])
  asset             Asset                    @relation(fields: [assetId], references: [id])
  anchor            EncryptionAnchor         @relation(fields: [anchorId], references: [id])
}

model OrganizationRiskSnapshot {
  id                      String   @id @default(uuid())
  snapshotTimestamp       DateTime @default(now()) @map("snapshot_timestamp") @db.Timestamptz
  totalAssets             Int      @map("total_assets")
  totalNonPqcAssets       Int      @map("total_non_pqc_assets")
  totalWrappedPqcAssets   Int      @map("total_wrapped_pqc_assets")
  totalAttestedAssets     Int      @map("total_attested_assets")
  highRiskAssetsCount     Int      @map("high_risk_assets_count")
  mediumRiskAssetsCount   Int      @map("medium_risk_assets_count")
  lowRiskAssetsCount      Int      @map("low_risk_assets_count")
  criticalRiskAssetsCount Int      @map("critical_risk_assets_count")
  policyCoveragePercent   Float    @map("policy_coverage_percent")
  assetsOutOfPolicy       Int      @map("assets_out_of_policy")
  comments                String?
}

model User {
  id           String    @id @default(uuid())
  email        String    @unique
  name         String
  role         UserRole
  passwordHash String    @map("password_hash")
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz
}
