#!/usr/bin/env node

/**
 * QuantumVault Integration Demo
 * Demonstrates the complete flow from upload to verification
 */

import { createHash, randomBytes } from 'crypto';
import { readFileSync, writeFileSync } from 'fs';

// Configuration
const QUANTUMVAULT_API_URL = process.env.VITE_QUANTUMVAULT_API_URL || 'https://quantumvault.dytallix.com';
const BLOCKCHAIN_API_URL = process.env.BLOCKCHAIN_API_URL || 'https://rpc.dytallix.com';

// Use built-in fetch (Node.js 18+) or import from node-fetch
const fetch = globalThis.fetch || (await import('node-fetch')).default;

/**
 * Generate a sample document to demonstrate with
 */
function generateSampleDocument() {
  const content = `
# QuantumVault Demo Document

This is a sample document to demonstrate QuantumVault's quantum-secure storage capabilities.

**Document Details:**
- Created: ${new Date().toISOString()}
- ID: ${randomBytes(8).toString('hex')}
- Type: Confidential Research Data
- Classification: Quantum-Protected

**Content:**
This document contains sensitive research data that requires long-term protection
against both classical and quantum computer attacks. QuantumVault ensures that
this data remains secure using post-quantum cryptographic algorithms.

**Features Demonstrated:**
1. Client-side BLAKE3 hashing
2. XChaCha20-Poly1305 encryption  
3. Post-quantum signature generation
4. Blockchain anchoring for immutable proof
5. Cryptographic verification

**Security Properties:**
- Confidentiality: Only authorized parties can decrypt
- Integrity: Any tampering is detected
- Authenticity: Cryptographic proof of origin
- Non-repudiation: Immutable blockchain record

---
Generated by QuantumVault Integration Demo
`.trim();

  return new TextEncoder().encode(content);
}

/**
 * Simulate client-side encryption (simplified for demo)
 */
function simulateEncryption(data) {
  // In real implementation, this would be XChaCha20-Poly1305
  const key = randomBytes(32);
  const nonce = randomBytes(24);
  const ciphertext = new Uint8Array(data.length);
  
  // Simple XOR for demo (NOT secure, just for demonstration)
  for (let i = 0; i < data.length; i++) {
    ciphertext[i] = data[i] ^ key[i % key.length];
  }
  
  return {
    ciphertext,
    key: key.toString('hex'),
    nonce: nonce.toString('hex')
  };
}

/**
 * Simulate post-quantum signature generation
 */
function generatePQSignature(data) {
  // In real implementation, this would be Dilithium
  const publicKey = randomBytes(1952).toString('hex'); // Dilithium public key size
  const signature = createHash('sha256').update(data).update(publicKey).digest('hex');
  
  return {
    publicKey,
    signature: signature + randomBytes(2420).toString('hex') // Dilithium signature size
  };
}

/**
 * Main demo function
 */
async function runDemo() {
  console.log('üöÄ QuantumVault Integration Demo\n');
  
  try {
    // Step 1: Generate sample document
    console.log('üìÑ Step 1: Generating sample document...');
    const originalData = generateSampleDocument();
    const originalHash = createHash('sha256').update(originalData).digest('hex');
    console.log(`   üìã Document size: ${originalData.length} bytes`);
    console.log(`   üîê BLAKE3 hash: ${originalHash}\n`);
    
    // Step 2: Client-side encryption
    console.log('üîí Step 2: Encrypting document...');
    const { ciphertext, key, nonce } = simulateEncryption(originalData);
    console.log(`   üîë Encryption key: ${key.slice(0, 16)}...`);
    console.log(`   üéØ Nonce: ${nonce.slice(0, 16)}...`);
    console.log(`   üì¶ Ciphertext size: ${ciphertext.length} bytes\n`);
    
    // Step 3: Upload to QuantumVault API
    console.log('üì§ Step 3: Uploading to QuantumVault...');
    const formData = new FormData();
    const blob = new Blob([ciphertext], { type: 'application/octet-stream' });
    formData.append('file', blob, `demo-${Date.now()}.enc`);
    formData.append('original_filename', 'quantum-demo-document.md');
    formData.append('mime', 'text/markdown');
    formData.append('blake3', originalHash);
    
    const uploadResponse = await fetch(`${QUANTUMVAULT_API_URL}/upload`, {
      method: 'POST',
      body: formData
    });
    
    if (!uploadResponse.ok) {
      throw new Error(`Upload failed: ${uploadResponse.status}`);
    }
    
    const uploadResult = await uploadResponse.json();
    console.log(`   üìç Storage URI: ${uploadResult.uri}`);
    console.log(`   ‚úÖ Upload successful\n`);
    
    // Step 4: Generate post-quantum proof
    console.log('üîè Step 4: Generating post-quantum proof...');
    const proofData = {
      schema: 'https://dytallix.com/proof/v1',
      file_hash_blake3: originalHash,
      uri: uploadResult.uri,
      created: new Date().toISOString(),
      meta: {
        filename: 'quantum-demo-document.md',
        mime: 'text/markdown',
        bytes: originalData.length
      }
    };
    
    const { publicKey, signature } = generatePQSignature(JSON.stringify(proofData));
    const proof = {
      ...proofData,
      owner_sig_pk: publicKey,
      signature: signature
    };
    
    console.log(`   üîë Public key: ${publicKey.slice(0, 32)}...`);
    console.log(`   ‚úçÔ∏è  Signature: ${signature.slice(0, 32)}...`);
    console.log(`   ‚úÖ Proof generated\n`);
    
    // Step 5: Register on blockchain
    console.log('‚öì Step 5: Anchoring on blockchain...');
    const registerResponse = await fetch(`${QUANTUMVAULT_API_URL}/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        blake3: originalHash,
        uri: uploadResult.uri,
        metadata: {
          filename: 'quantum-demo-document.md',
          demo: true,
          proof_schema: proof.schema,
          timestamp: new Date().toISOString()
        }
      })
    });
    
    if (!registerResponse.ok) {
      throw new Error(`Registration failed: ${registerResponse.status}`);
    }
    
    const registerResult = await registerResponse.json();
    console.log(`   üîó Transaction hash: ${registerResult.txHash || registerResult.transactionHash}`);
    console.log(`   üÜî Asset ID: ${registerResult.assetId}`);
    console.log(`   üìä Block height: ${registerResult.blockHeight || 'pending'}`);
    console.log(`   ‚úÖ Blockchain registration successful\n`);
    
    // Step 6: Verify the registration
    console.log('‚úÖ Step 6: Verifying blockchain registration...');
    await new Promise(resolve => setTimeout(resolve, 1000)); // Brief delay
    
    const verifyResponse = await fetch(`${QUANTUMVAULT_API_URL}/verify/${originalHash}`);
    if (!verifyResponse.ok) {
      throw new Error(`Verification failed: ${verifyResponse.status}`);
    }
    
    const verifyResult = await verifyResponse.json();
    console.log(`   üîç Verification status: ${verifyResult.verified ? 'VERIFIED ‚úÖ' : 'FAILED ‚ùå'}`);
    console.log(`   üîó Transaction: ${verifyResult.tx_hash || verifyResult.txHash}`);
    console.log(`   ‚è∞ Timestamp: ${new Date(verifyResult.timestamp * 1000 || Date.now()).toLocaleString()}\n`);
    
    // Step 7: Generate downloadable proof certificate
    console.log('üìú Step 7: Generating proof certificate...');
    const certificate = {
      ...proof,
      blockchain_anchor: {
        tx_hash: registerResult.txHash || registerResult.transactionHash,
        asset_id: registerResult.assetId,
        block_height: registerResult.blockHeight,
        verified: verifyResult.verified,
        verification_time: new Date().toISOString()
      }
    };
    
    const certificateJson = JSON.stringify(certificate, null, 2);
    const certificateFilename = `quantum-proof-${originalHash.slice(0, 16)}.json`;
    writeFileSync(certificateFilename, certificateJson);
    
    console.log(`   üìã Certificate saved: ${certificateFilename}`);
    console.log(`   üìè Certificate size: ${certificateJson.length} bytes`);
    console.log(`   ‚úÖ Proof certificate generated\n`);
    
    // Summary
    console.log('üéâ Demo completed successfully!\n');
    console.log('üìä Summary:');
    console.log(`   üìÑ Original document: ${originalData.length} bytes`);
    console.log(`   üîê Hash: ${originalHash}`);
    console.log(`   üìç Storage URI: ${uploadResult.uri}`);
    console.log(`   üîó Transaction: ${registerResult.txHash || registerResult.transactionHash}`);
    console.log(`   ‚úÖ Verified on blockchain: ${verifyResult.verified ? 'YES' : 'NO'}`);
    console.log(`   üìú Certificate: ${certificateFilename}\n`);
    
    console.log('üîß Next steps:');
    console.log('   1. Open the frontend: http://localhost:5173/#/quantumvault');
    console.log('   2. Upload your own files using the web interface');
    console.log('   3. Verify the generated proof certificate');
    console.log(`   4. Check the certificate file: ${certificateFilename}\n`);
    
    console.log('‚ú® QuantumVault provides quantum-secure storage with cryptographic proof!');
    
  } catch (error) {
    console.error('‚ùå Demo failed:', error.message);
    console.log('\nüîß Troubleshooting:');
    console.log('   1. Ensure all services are running: ./start-quantumvault.sh');
    console.log('   2. Check service logs for errors');
    console.log('   3. Verify network connectivity');
    process.exit(1);
  }
}

// Run the demo
runDemo().catch(console.error);
